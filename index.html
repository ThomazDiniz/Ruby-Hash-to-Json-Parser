<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ruby Hash ↔ JSON Parser</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f5f5f5;
            display: flex;
            flex-direction: column;
        }

        .header {
            padding: 10px 20px;
            background: white;
            border-bottom: 1px solid #ddd;
            flex-shrink: 0;
        }

        h1 {
            margin: 0;
            color: #333;
            font-size: 1.5em;
            text-align: center;
        }

        .container {
            flex: 1;
            display: flex;
            overflow: hidden;
            padding: 10px;
            gap: 10px;
        }

        .main-content {
            flex: 1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            min-width: 0;
        }

        .panel {
            display: flex;
            flex-direction: column;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
            min-width: 0;
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #f9f9f9;
            border-bottom: 1px solid #ddd;
            flex-shrink: 0;
        }

        .section-title {
            font-size: 1em;
            color: #333;
            font-weight: 600;
        }

        .button-group {
            display: flex;
            gap: 8px;
        }

        button {
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            background: #4facfe;
            color: white;
        }

        button:hover {
            background: #00f2fe;
        }

        textarea {
            width: 100%;
            flex: 1;
            padding: 12px;
            border: none;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            resize: none;
            outline: none;
            overflow: auto;
        }

        .error-message {
            background: #fee;
            color: #c33;
            padding: 8px 12px;
            font-size: 12px;
            border-top: 1px solid #ddd;
            display: none;
            flex-shrink: 0;
        }

        .error-message.show {
            display: block;
        }

        .divider {
            width: 1px;
            background: #ddd;
            flex-shrink: 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Ruby Hash ↔ JSON Parser</h1>
    </div>
    <div class="container">
        <div class="main-content">
            <div class="panel">
                <div class="panel-header">
                    <div class="section-title">Ruby Hash</div>
                    <div class="button-group">
                        <button class="btn-success" onclick="beautifyRuby()">Beautify</button>
                    </div>
                </div>
                <textarea id="rubyInput" placeholder='Exemplo: { name: "João", age: 30, active: true, tags: ["ruby", "json"] }'></textarea>
                <div id="rubyError" class="error-message"></div>
            </div>

            <div class="panel">
                <div class="panel-header">
                    <div class="section-title">JSON</div>
                    <div class="button-group">
                        <button class="btn-success" onclick="beautifyJson()">Beautify</button>
                    </div>
                </div>
                <textarea id="jsonInput" placeholder='{"name":"João","age":30,"active":true,"tags":["ruby","json"]}'></textarea>
                <div id="jsonError" class="error-message"></div>
            </div>
        </div>
    </div>

    <script>
        let isUpdating = false;

        // Parser de Ruby Hash para JavaScript Object
        function parseRubyHash(rubyCode) {
            let pos = 0;
            const len = rubyCode.length;

            function skipWhitespace() {
                while (pos < len && /\s/.test(rubyCode[pos])) {
                    pos++;
                }
            }

            function parseString() {
                const quote = rubyCode[pos];
                if (quote !== '"' && quote !== "'") {
                    return null;
                }
                pos++;
                let str = '';
                let escaped = false;
                
                while (pos < len) {
                    const char = rubyCode[pos];
                    if (escaped) {
                        if (char === 'n') str += '\n';
                        else if (char === 't') str += '\t';
                        else if (char === 'r') str += '\r';
                        else if (char === '\\') str += '\\';
                        else if (char === quote) str += quote;
                        else str += char;
                        escaped = false;
                    } else if (char === '\\') {
                        escaped = true;
                    } else if (char === quote) {
                        pos++;
                        return str;
                    } else {
                        str += char;
                    }
                    pos++;
                }
                throw new Error('String não terminada');
            }

            function parseSymbol() {
                if (rubyCode[pos] !== ':') return null;
                pos++;
                let symbol = '';
                if (rubyCode[pos] === '"' || rubyCode[pos] === "'") {
                    const str = parseString();
                    return str !== null ? str : null;
                }
                while (pos < len && /[a-zA-Z0-9_]/.test(rubyCode[pos])) {
                    symbol += rubyCode[pos];
                    pos++;
                }
                return symbol;
            }

            function parseNumber() {
                let numStr = '';
                let hasDot = false;
                const start = pos;
                
                if (rubyCode[pos] === '-') {
                    numStr += '-';
                    pos++;
                }
                
                while (pos < len) {
                    const char = rubyCode[pos];
                    if (char === '.') {
                        if (hasDot) break;
                        hasDot = true;
                        numStr += '.';
                    } else if (/[0-9]/.test(char)) {
                        numStr += char;
                    } else {
                        break;
                    }
                    pos++;
                }
                
                if (numStr && numStr !== '-') {
                    return hasDot ? parseFloat(numStr) : parseInt(numStr, 10);
                }
                pos = start;
                return null;
            }

            function parseKeyword() {
                const keywords = {
                    'nil': null,
                    'true': true,
                    'false': false
                };
                
                for (const [keyword, value] of Object.entries(keywords)) {
                    if (rubyCode.substring(pos, pos + keyword.length) === keyword) {
                        const nextChar = rubyCode[pos + keyword.length];
                        if (!nextChar || !/[a-zA-Z0-9_]/.test(nextChar)) {
                            pos += keyword.length;
                            return { found: true, value: value };
                        }
                    }
                }
                return { found: false, value: null };
            }

            function parseValue() {
                skipWhitespace();
                
                if (pos >= len) return null;

                // Array
                if (rubyCode[pos] === '[') {
                    return parseArray();
                }

                // Hash/Object
                if (rubyCode[pos] === '{') {
                    return parseObject();
                }

                // String
                if (rubyCode[pos] === '"' || rubyCode[pos] === "'") {
                    return parseString();
                }

                // Symbol
                if (rubyCode[pos] === ':') {
                    return parseSymbol();
                }

                // Number
                const num = parseNumber();
                if (num !== null) return num;

                // Keyword (nil, true, false)
                const keyword = parseKeyword();
                if (keyword.found) return keyword.value;

                throw new Error(`Caractere inesperado na posição ${pos}: ${rubyCode[pos]}`);
            }

            function parseArray() {
                if (rubyCode[pos] !== '[') {
                    throw new Error('Esperado "["');
                }
                pos++;
                skipWhitespace();
                
                const arr = [];
                
                if (rubyCode[pos] === ']') {
                    pos++;
                    return arr;
                }

                while (pos < len) {
                    skipWhitespace();
                    const value = parseValue();
                    if (value === null && rubyCode[pos] !== ']') {
                        throw new Error('Valor inválido no array');
                    }
                    arr.push(value);
                    
                    skipWhitespace();
                    if (rubyCode[pos] === ']') {
                        pos++;
                        break;
                    }
                    if (rubyCode[pos] !== ',') {
                        throw new Error('Esperado "," ou "]"');
                    }
                    pos++;
                }
                
                return arr;
            }

            function parseObject() {
                if (rubyCode[pos] !== '{') {
                    throw new Error('Esperado "{"');
                }
                pos++;
                skipWhitespace();
                
                const obj = {};
                
                if (rubyCode[pos] === '}') {
                    pos++;
                    return obj;
                }

                while (pos < len) {
                    skipWhitespace();
                    
                    // Parse key
                    let key = null;
                    
                    // Symbol key
                    if (rubyCode[pos] === ':') {
                        key = parseSymbol();
                    }
                    // String key
                    else if (rubyCode[pos] === '"' || rubyCode[pos] === "'") {
                        key = parseString();
                    }
                    // Identifier key (sem aspas)
                    else {
                        let ident = '';
                        while (pos < len && /[a-zA-Z0-9_]/.test(rubyCode[pos])) {
                            ident += rubyCode[pos];
                            pos++;
                        }
                        if (ident) {
                            key = ident;
                        }
                    }
                    
                    if (!key) {
                        throw new Error('Chave inválida');
                    }
                    
                    skipWhitespace();
                    
                    // Parse => or :
                    if (rubyCode.substring(pos, pos + 2) === '=>') {
                        pos += 2;
                    } else if (rubyCode[pos] === ':') {
                        pos++;
                    } else {
                        throw new Error('Esperado "=>" ou ":"');
                    }
                    
                    skipWhitespace();
                    
                    // Parse value
                    const value = parseValue();
                    obj[key] = value;
                    
                    skipWhitespace();
                    
                    if (rubyCode[pos] === '}') {
                        pos++;
                        break;
                    }
                    if (rubyCode[pos] !== ',') {
                        throw new Error('Esperado "," ou "}"');
                    }
                    pos++;
                }
                
                return obj;
            }

            skipWhitespace();
            const result = parseValue();
            skipWhitespace();
            
            if (pos < len) {
                throw new Error(`Caracteres extras após o final: ${rubyCode.substring(pos)}`);
            }
            
            return result;
        }

        // Função recursiva para converter JSON para Ruby Hash
        function jsonToRubyHash(obj, indent = 0) {
            const indentStr = '  '.repeat(indent);
            const nextIndent = indent + 1;
            const nextIndentStr = '  '.repeat(nextIndent);

            if (obj === null) {
                return 'nil';
            }

            if (typeof obj === 'string') {
                return `"${obj.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n').replace(/\t/g, '\\t').replace(/\r/g, '\\r')}"`;
            }

            if (typeof obj === 'number' || typeof obj === 'boolean') {
                return String(obj);
            }

            if (Array.isArray(obj)) {
                if (obj.length === 0) {
                    return '[]';
                }
                
                const isSimpleArray = obj.every(item => 
                    item === null || 
                    typeof item !== 'object' || 
                    (Array.isArray(item) && item.length === 0)
                );
                
                if (isSimpleArray && obj.length <= 5) {
                    const items = obj.map(item => jsonToRubyHash(item, 0));
                    return '[' + items.join(', ') + ']';
                }
                
                const items = obj.map(item => {
                    const value = jsonToRubyHash(item, nextIndent);
                    return nextIndentStr + value;
                });
                return '[\n' + items.join(',\n') + '\n' + indentStr + ']';
            }

            if (typeof obj === 'object') {
                const keys = Object.keys(obj);
                if (keys.length === 0) {
                    return '{}';
                }
                
                const pairs = keys.map(key => {
                    const value = obj[key];
                    const rubyKey = /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key) ? `:${key}` : `"${key}"`;
                    const rubyValue = jsonToRubyHash(value, nextIndent);
                    
                    return nextIndentStr + `${rubyKey} => ${rubyValue}`;
                });
                return '{\n' + pairs.join(',\n') + '\n' + indentStr + '}';
            }

            return String(obj);
        }

        // Função para atualizar JSON quando Ruby Hash muda
        function updateJsonFromRuby() {
            if (isUpdating) return;
            
            const rubyInput = document.getElementById('rubyInput').value.trim();
            const errorDiv = document.getElementById('rubyError');
            
            errorDiv.classList.remove('show');

            if (!rubyInput) {
                document.getElementById('jsonInput').value = '';
                return;
            }

            try {
                isUpdating = true;
                const jsonObj = parseRubyHash(rubyInput);
                const jsonString = JSON.stringify(jsonObj, null, 2);
                document.getElementById('jsonInput').value = jsonString;
            } catch (error) {
                // Não mostrar erro, apenas não atualizar
            } finally {
                isUpdating = false;
            }
        }

        // Função para atualizar Ruby Hash quando JSON muda
        function updateRubyFromJson() {
            if (isUpdating) return;
            
            const jsonInput = document.getElementById('jsonInput').value.trim();
            const errorDiv = document.getElementById('jsonError');
            
            errorDiv.classList.remove('show');

            if (!jsonInput) {
                document.getElementById('rubyInput').value = '';
                return;
            }

            try {
                isUpdating = true;
                const jsonObj = JSON.parse(jsonInput);
                const rubyHash = jsonToRubyHash(jsonObj, 0);
                document.getElementById('rubyInput').value = rubyHash;
            } catch (error) {
                // Não mostrar erro, apenas não atualizar
            } finally {
                isUpdating = false;
            }
        }

        // Função para beautify Ruby Hash
        function beautifyRuby() {
            const rubyInput = document.getElementById('rubyInput').value.trim();
            const errorDiv = document.getElementById('rubyError');
            
            errorDiv.classList.remove('show');

            if (!rubyInput) {
                return;
            }

            try {
                const jsonObj = parseRubyHash(rubyInput);
                const beautified = jsonToRubyHash(jsonObj, 0);
                document.getElementById('rubyInput').value = beautified;
                updateJsonFromRuby();
            } catch (error) {
                showError('rubyError', `Erro ao formatar: ${error.message}`);
            }
        }

        // Função para beautify JSON
        function beautifyJson() {
            const jsonInput = document.getElementById('jsonInput').value.trim();
            const errorDiv = document.getElementById('jsonError');
            
            errorDiv.classList.remove('show');

            if (!jsonInput) {
                return;
            }

            try {
                const jsonObj = JSON.parse(jsonInput);
                const beautified = JSON.stringify(jsonObj, null, 2);
                document.getElementById('jsonInput').value = beautified;
                updateRubyFromJson();
            } catch (error) {
                showError('jsonError', `Erro ao formatar: ${error.message}`);
            }
        }

        // Função auxiliar para mensagens de erro
        function showError(elementId, message) {
            const errorDiv = document.getElementById(elementId);
            errorDiv.textContent = message;
            errorDiv.classList.add('show');
        }

        // Event listeners para atualização em tempo real
        let rubyTimeout;
        let jsonTimeout;

        document.getElementById('rubyInput').addEventListener('input', function() {
            clearTimeout(rubyTimeout);
            rubyTimeout = setTimeout(updateJsonFromRuby, 300);
        });

        document.getElementById('jsonInput').addEventListener('input', function() {
            clearTimeout(jsonTimeout);
            jsonTimeout = setTimeout(updateRubyFromJson, 300);
        });
    </script>
</body>
</html>
